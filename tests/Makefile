
.DEFAULT_GOAL := help
.PHONY: help all build clean gate test tests regression quick perf perf-quick perf-small perf-full graphs $(TARGETS)

GATE_MAX_OVERALL_MEDIAN_MS ?= 1500
PYTHON ?= python3

# default: show help when `make` is run with no args
help:
	@echo "usage: make [target]"
	@echo
	@echo "Available Targets:"
	@echo "  help                    - show this message (default)"
	@echo "  all                     - run a series of lightweight, default tests"
	@echo "  build                   - run tests/ build"
	@echo "  clean                   - clean tests/ artifacts"
	@echo "  gate                    - run preflight pass/fail checks (regression + perf budget)"
	@echo "  graphs                  - generate PNG graphs from full perf CSV in tests/data/"
	@echo "  perf                    - run quick performance gauge"
	@echo "  perf-full               - run full 252 performance matrix (writes tests/data/)"
	@echo "  perf-quick              - run quick performance gauge"
	@echo "  perf-small              - run smaller performance matrix"
	@echo "  quick                   - run fast regression suite"
	@echo "  regression              - run fast regression suite"
	@echo "  test                    - alias for tests"
	@echo "  tests                   - run all tests, including scripts"
	@echo
	@echo "Script Targets:"
	@for t in $(TARGETS); do \
		echo "  $$t"; \
	done
	@echo

#
# init
#

# find executables with a shebang
SCRIPTS := $(shell find . -type f -perm /111 -print | sort | xargs -I{} sh -c 'head -n1 "{}" 2>/dev/null | sed -n "1p" | grep -q "^#!" && echo "{}" || true' | sed 's|^./||')

# dynamic target names for scripts with a shebang (e.g. "test.example" for "test/example.sh")
TARGETS := $(foreach s,$(SCRIPTS),$(subst /,.,$(basename $(s))))

# dynamic rule generator: create a rule for each discovered script
define RUN_RULE
$(1):
	@echo "++ Running $(2) ..."
	@echo --cut--
	@./$(2)
	@echo --cut--
	@echo
endef
$(foreach s,$(SCRIPTS),$(eval $(call RUN_RULE,$(subst /,.,$(basename $(s))),$(s))))

#
# targets
#

all: build clean gate

build:
	@echo "++ Building tests/ ..."
	@echo

clean:
	@echo "++ Cleaning tests/ artifacts ..."
	@echo

	# remove __pycache__
	-@rm -rf __pycache__

	# remove temporary files
	-@rm -rf node_modules .cache tmp

	# remove performance artifacts generated by keybindings-sort.test_performance.py
	-@rm -f ../tmp/perf-keybindings-sort.*.json ../tmp/perf-keybindings-sort.*.csv

# pass/fail gate performance budget is configurable at invocation time, for example: make gate GATE_MAX_OVERALL_MEDIAN_MS=1200
gate:
	@echo "++ Running gate checks ..."
	@echo --cut--
	@./keybindings-sort.test_quick_regression.py
	@./keybindings-sort.test_performance.py --mode quick --max-overall-median-ms $(GATE_MAX_OVERALL_MEDIAN_MS)
	@echo --cut--
	@echo

perf: perf-quick

graphs:
	@echo "++ Generating performance graphs ..."
	@echo --cut--
	@command -v $(PYTHON) >/dev/null 2>&1 || { echo "error: $(PYTHON) not found in PATH"; exit 2; }
	@$(PYTHON) ./keybindings-sort.test_performance.graphs.py --input tests/data/perf-keybindings-sort.full.csv --out-dir tests/data
	@echo --cut--
	@echo

perf-full:
	@echo "++ Running full 252 performance matrix ..."
	@echo --cut--
	@./keybindings-sort.test_performance.py --mode full --out-prefix ./data/perf-keybindings-sort.full
	@echo --cut--
	@echo

perf-quick:
	@echo "++ Running quick performance gauge ..."
	@echo --cut--
	@./keybindings-sort.test_performance.py --mode quick
	@echo --cut--
	@echo

perf-small:
	@echo "++ Running smaller performance matrix ..."
	@echo --cut--
	@./keybindings-sort.test_performance.py --mode small --runs-per-combo 1 --warmup-runs 0
	@echo --cut--
	@echo

quick: regression

regression:
	@echo "++ Running quick regression suite ..."
	@echo --cut--
	@./keybindings-sort.test_quick_regression.py
	@echo --cut--
	@echo

test: tests

tests: $(TARGETS)