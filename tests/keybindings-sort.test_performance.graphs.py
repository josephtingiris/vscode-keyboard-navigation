#!/usr/bin/env python3
"""
(C) 2026 Joseph Tingiris (joseph.tingiris@gmail.com)

Generate PNG performance graphs from keybindings-sort benchmark CSV data.

Usage:
    keybindings-sort.test_performance.graphs.py
    keybindings-sort.test_performance.graphs.py --input tests/data/perf-keybindings-sort.full.csv --out-dir tests/data

Behavior:
- reads a benchmark CSV generated by keybindings-sort.test_performance.py
- writes PNG graphs to the output directory
- exits with 0 on success, non-zero on errors
"""

from __future__ import annotations

import argparse
import csv
import statistics
import sys
from pathlib import Path


def parse_args() -> argparse.Namespace:
    """Parse command-line options."""
    parser = argparse.ArgumentParser(description="Generate PNG graphs from keybindings-sort performance CSV")
    parser.add_argument(
        "--input",
        default="tests/data/perf-keybindings-sort.full.csv",
        help="input CSV file generated by keybindings-sort.test_performance.py",
    )
    parser.add_argument(
        "--out-dir",
        default="tests/data",
        help="directory for generated PNG files",
    )
    return parser.parse_args()


def load_rows(csv_path: Path) -> list[dict[str, str | float | int]]:
    """Load benchmark rows from CSV."""
    rows: list[dict[str, str | float | int]] = []
    with csv_path.open(encoding="utf-8", newline="") as handle:
        reader = csv.DictReader(handle)
        for row in reader:
            rows.append(
                {
                    "primary": row["primary"],
                    "secondary": row["secondary"],
                    "group_sorting": row["group_sorting"],
                    "when_grouping": row["when_grouping"],
                    "object_clones": int(row["object_clones"]),
                    "median_ms": float(row["median_ms"]),
                }
            )
    return rows


def aggregate_median(rows: list[dict[str, str | float | int]], key: str) -> dict[str, float]:
    """Return median median_ms grouped by a categorical key."""
    grouped: dict[str, list[float]] = {}
    for row in rows:
        label = str(row[key])
        grouped.setdefault(label, []).append(float(row["median_ms"]))
    return {label: statistics.median(values) for label, values in grouped.items()}


def save_histogram(rows: list[dict[str, str | float | int]], out_path: Path) -> None:
    """Save histogram for median runtime distribution."""
    import matplotlib.pyplot as plt

    values = [float(row["median_ms"]) for row in rows]
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.hist(values, bins=20)
    ax.set_title("keybindings-sort full matrix: median runtime distribution")
    ax.set_xlabel("median runtime (ms)")
    ax.set_ylabel("count")
    fig.tight_layout()
    fig.savefig(out_path, dpi=120)
    plt.close(fig)


def save_group_sorting_chart(rows: list[dict[str, str | float | int]], out_path: Path) -> None:
    """Save bar chart for group_sorting median impact."""
    import matplotlib.pyplot as plt

    data = aggregate_median(rows, "group_sorting")
    labels = sorted(data.keys(), key=lambda key: data[key])
    values = [data[label] for label in labels]

    fig, ax = plt.subplots(figsize=(11, 6))
    ax.bar(labels, values)
    ax.set_title("median runtime by group_sorting")
    ax.set_xlabel("group_sorting")
    ax.set_ylabel("median runtime (ms)")
    ax.tick_params(axis="x", rotation=20)
    fig.tight_layout()
    fig.savefig(out_path, dpi=120)
    plt.close(fig)


def save_when_grouping_chart(rows: list[dict[str, str | float | int]], out_path: Path) -> None:
    """Save bar chart for when_grouping median impact."""
    import matplotlib.pyplot as plt

    data = aggregate_median(rows, "when_grouping")
    labels = sorted(data.keys(), key=lambda key: data[key])
    values = [data[label] for label in labels]

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.bar(labels, values)
    ax.set_title("median runtime by when_grouping")
    ax.set_xlabel("when_grouping")
    ax.set_ylabel("median runtime (ms)")
    fig.tight_layout()
    fig.savefig(out_path, dpi=120)
    plt.close(fig)


def main() -> int:
    """Generate performance graphs from a benchmark CSV file."""
    args = parse_args()
    root = Path(__file__).resolve().parent.parent
    input_path = (root / args.input).resolve()
    out_dir = (root / args.out_dir).resolve()

    if not input_path.exists():
        print(f"error: missing input csv: {input_path}", file=sys.stderr)
        return 2

    try:
        import matplotlib  # noqa: F401
    except ImportError:
        print("error: matplotlib is required. install with '.venv/bin/pip install matplotlib'", file=sys.stderr)
        return 2

    out_dir.mkdir(parents=True, exist_ok=True)
    rows = load_rows(input_path)
    if not rows:
        print(f"error: no rows found in csv: {input_path}", file=sys.stderr)
        return 2

    base = input_path.stem
    save_histogram(rows, out_dir / f"{base}.histogram.png")
    save_group_sorting_chart(rows, out_dir / f"{base}.group-sorting-median.png")
    save_when_grouping_chart(rows, out_dir / f"{base}.when-grouping-median.png")

    print(f"++ wrote graphs to {out_dir}")
    print(f"  - {base}.histogram.png")
    print(f"  - {base}.group-sorting-median.png")
    print(f"  - {base}.when-grouping-median.png")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
